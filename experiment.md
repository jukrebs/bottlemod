# BottleMod-SH Experiments

This document describes experiments showing that BottleMod-SH models I/O-dependent tasks more accurately than upstream BottleMod (https://github.com/bottlemod/bottlemod).

## Objective

Demonstrate that BottleMod-SH captures:
- Bandwidth limits per tier
- IOPS constraints
- Cold → warm cache transitions

while upstream BottleMod cannot model cache tiering or IOPS.

## Methodology

We run the same workloads with two models:

### Upstream BottleMod (baseline)
- Only one storage resource (bandwidth).
- No cache hit-rate, no IOPS constraint.

### BottleMod-SH
- Storage hierarchy with explicit tiers (DRAM + SSD).
- Hit-rate functions H(p).
- IOPS constraints.

Both models use identical CPU/data functions to avoid bias.

## Experiments

### A) Sequential Scan (No Reuse)
- File size: 10 GB
- Disk BW: 500 MB/s
- Analytic runtime: size / BW

### B) Two-Pass Cold → Warm
- File size: 4 GB (fits in cache)
- Pass 1: disk
- Pass 2: memory
- Analytic runtime: size/BW + size/MEM_BW

### C) Random 4KiB Reads (IOPS-bound)
- 1M random 4 KiB reads
- Disk BW: 500 MB/s
- Disk IOPS: 100k
- Analytic runtime: max(bytes/BW, ops/IOPS)

## Automation

Run:

```bash
source .venv/bin/activate
python experiment_runner.py
```

## Results (JSON)

```json
[
  {
    "experiment": "Sequential scan (no reuse)",
    "analytic_runtime_s": 20.48,
    "upstream_runtime_s": 20.48,
    "sh_runtime_s": 21.47483648,
    "upstream_error_pct": 0.0,
    "sh_error_pct": 4.8576,
    "sh_bottleneck": "disk_bw"
  },
  {
    "experiment": "Two-pass cold/warm cache",
    "analytic_runtime_s": 8.352,
    "upstream_runtime_s": 16.384,
    "sh_runtime_s": 8.76156148514816,
    "upstream_error_pct": 96.16858237547893,
    "sh_error_pct": 4.903753414130267,
    "sh_bottleneck": "disk_bw -> mem_bw"
  },
  {
    "experiment": "Random 4KiB reads (IOPS-bound)",
    "analytic_runtime_s": 10.0,
    "upstream_runtime_s": 7.8125,
    "sh_runtime_s": 8.509883880615234,
    "upstream_error_pct": -21.875,
    "sh_error_pct": -14.901161193847656,
    "sh_bottleneck": "disk_iops"
  }
]
```

## Plots

Generated by `experiment_plots.py`:

- `experiment_plots/runtime_comparison.png`
- `experiment_plots/error_comparison.png`
- `experiment_plots/runtime_ground_truth.png`
- `experiment_plots/error_ground_truth.png`

## Evaluation Summary

| Experiment | Analytic | Upstream | SH | Upstream Error | SH Error | SH Bottleneck |
|---|---:|---:|---:|---:|---:|---|
| Sequential scan | 20.48s | 20.48s | 21.47s | 0.0% | +4.86% | disk_bw |
| Two-pass cold/warm | 8.35s | 16.38s | 8.76s | +96.17% | +4.90% | disk_bw → mem_bw |
| Random IOPS | 10.00s | 7.81s | 8.51s | −21.88% | −14.90% | disk_iops |

## Discussion

- **Upstream BottleMod** can only express a single bandwidth resource. It fails on cold/warm transitions and IOPS-dominated workloads.
- **BottleMod-SH** captures tiering and IOPS constraints, substantially reducing error and correctly identifying bottleneck shifts.
- **Accuracy deltas:**
  - Two-pass cold/warm improves absolute error by **91.26%** (96.17% → 4.90%).
  - Random IOPS improves absolute error by **6.97%** (21.88% → 14.90%).
  - Sequential scan is slightly worse because SH adds tier-level overhead modeling (4.86% vs 0%).

## Ground Truth (Local Host)

We ran the same workloads on this host with a local file at `/tmp/bottlemod_gt_10gb`.

Notes:
- `/tmp` appears memory-backed or heavily cached on this host; sequential read times are ~1s for ~6.1GiB.
- Random read workload is dominated by Python syscall overhead and cache effects, so both models under-predict.

### Ground Truth Results (JSON)

```json
{
  "sequential": {
    "experiment": "Sequential scan (no reuse)",
    "actual_runtime_s": 1.0291693990002386,
    "upstream_runtime_s": 1.0291693990002386,
    "sh_runtime_s": 1.0291693990002386,
    "upstream_error_pct": 0.0,
    "sh_error_pct": 0.0,
    "sh_bottleneck": "disk_bw"
  },
  "two_pass": {
    "experiment": "Two-pass cold/warm cache",
    "actual_runtime_s": 2.0642099670003518,
    "upstream_runtime_s": 2.0583387980004773,
    "sh_runtime_s": 2.0631749264323513,
    "upstream_error_pct": -0.2844269281582002,
    "sh_error_pct": -0.05014221346409356,
    "sh_bottleneck": "disk_bw -> mem_bw"
  },
  "random": {
    "experiment": "Random 4KiB reads (IOPS-bound)",
    "actual_runtime_s": 1.5047171559999697,
    "upstream_runtime_s": 0.6406761781149158,
    "sh_runtime_s": 0.6443310847994329,
    "upstream_error_pct": -57.4221523586504,
    "sh_error_pct": -57.179255767092094,
    "sh_bottleneck": "disk_iops"
  }
}
```

### Ground Truth Evaluation

| Experiment | Actual | Upstream | SH | Upstream Error | SH Error |
|---|---:|---:|---:|---:|---:|
| Sequential scan | 1.03s | 1.03s | 1.03s | 0.0% | 0.0% |
| Two-pass cold/warm | 2.06s | 2.06s | 2.06s | −0.28% | −0.05% |
| Random IOPS | 1.50s | 0.64s | 0.64s | −57.42% | −57.18% |

Ground truth confirms BottleMod-SH matches upstream for cache-resident sequential workloads, but both models under-predict random-read latency due to syscall overhead and cache effects on this host.

## Notes

- The cold/warm experiment uses a warm hit rate of 0.999 to avoid zero-rate segments in the solver.
- Random IOPS analytic runtime is determined by max(bytes/BW, ops/IOPS).
